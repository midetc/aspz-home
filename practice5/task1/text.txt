Коли ви запускаєте цю програму, спершу викликається функція `build_message`, яка виділяє в купі пам’ять під вашу рядкову константу `“Hello, FreeBSD!”`, копіює туди символи і повертає вказівник на початок цього блоку. Після цього в `main()` виконується виклик  
```c
printf("before: %s\n", msg);
```  
і ви бачите на екрані  
```
before: Hello, FreeBSD!
```  
– усе за планом.

А потім трапляється «витяг» права власності: функція `log_and_maybe_free(msg)` друкує повідомлення  
```c
log: Hello, FreeBSD!
```  
і одразу ж викликає `free(msg)`, хоча за домовленістю саме `main()` повинен був звільняти цю пам’ять. Після повернення з `log_and_maybe_free` у вас залишається «вішачий» вказівник `msg`, який нікому не належить — пам’ять уже віддана назад алокатору і може бути перерозподілена або помічена як вільна. 

Незважаючи на це, програма в наступному рядку робить  
```c
printf("after:  %s\n", msg);
```  
і шукає в пам’яті те, що раніше було вашим рядком. Звичайний `jemalloc` у FreeBSD часто залишає старі дані на місці доти, доки хтось не попросить новий блок, тому ви іноді навіть бачите «Hello, FreeBSD!» і тут. Але ця ситуація вже є **undefined behaviour** – нічого гарантовано не працює.

Коли ж ви запускаєте програму з AddressSanitizer, цей інструмент навколо кожного шматка купи малює «червоні зони». Як тільки програма робить повторний `printf` по вже звільненому вказівнику, ASan бачить, що це читання зі «звільненої» ділянки, і негайно зупиняє виконання, повідомивши в лог рядок про **heap-use-after-free** та вказавши, де саме пам’ять була вільнена (в `log_and_maybe_free`) і де вона вдруге використана (в `main`). 

На завершення `main()` ще викликає `free(msg)` вдруге, що відловлюється як **double-free**, але в типовій ASan-налаштуванні програма вже припинена до цього кроку. Отже, ми бачимо ілюстрацію того, як “похитнення” правила власності на пам’ять призводить до непередбачуваних помилок і обов’язково виявляється інструментами типу AddressSanitizer.